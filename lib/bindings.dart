// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to the ouisync library
class Bindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Bindings(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Bindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void file_open(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _file_open(
      session,
      repo,
      path,
      port,
    );
  }

  late final _file_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              Port_Result_Handle_FileHolder)>>('file_open');
  late final _file_open = _file_openPtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  void file_create(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _file_create(
      session,
      repo,
      path,
      port,
    );
  }

  late final _file_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              Port_Result_Handle_FileHolder)>>('file_create');
  late final _file_create = _file_createPtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// Remove (delete) the file at the given path from the repository.
  void file_remove(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _file_remove(
      session,
      repo,
      path,
      port,
    );
  }

  late final _file_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>, Port_Result)>>('file_remove');
  late final _file_remove = _file_removePtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  void file_close(
    int session,
    int handle,
    int port,
  ) {
    return _file_close(
      session,
      handle,
      port,
    );
  }

  late final _file_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_FileHolder, Port_Result)>>('file_close');
  late final _file_close =
      _file_closePtr.asFunction<void Function(int, int, int)>();

  void file_flush(
    int session,
    int handle,
    int port,
  ) {
    return _file_flush(
      session,
      handle,
      port,
    );
  }

  late final _file_flushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_FileHolder, Port_Result)>>('file_flush');
  late final _file_flush =
      _file_flushPtr.asFunction<void Function(int, int, int)>();

  /// Read at most `len` bytes from the file into `buffer`. Yields the number of bytes actually read
  /// (zero on EOF).
  void file_read(
    int session,
    int handle,
    int offset,
    ffi.Pointer<ffi.Uint8> buffer,
    int len,
    int port,
  ) {
    return _file_read(
      session,
      handle,
      offset,
      buffer,
      len,
      port,
    );
  }

  late final _file_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_FileHolder,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              Port_Result_u64)>>('file_read');
  late final _file_read = _file_readPtr.asFunction<
      void Function(int, int, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Write `len` bytes from `buffer` into the file.
  void file_write(
    int session,
    int handle,
    int offset,
    ffi.Pointer<ffi.Uint8> buffer,
    int len,
    int port,
  ) {
    return _file_write(
      session,
      handle,
      offset,
      buffer,
      len,
      port,
    );
  }

  late final _file_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_FileHolder, ffi.Uint64,
              ffi.Pointer<ffi.Uint8>, ffi.Uint64, Port_Result)>>('file_write');
  late final _file_write = _file_writePtr.asFunction<
      void Function(int, int, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Truncate the file to `len` bytes.
  void file_truncate(
    int session,
    int handle,
    int len,
    int port,
  ) {
    return _file_truncate(
      session,
      handle,
      len,
      port,
    );
  }

  late final _file_truncatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_FileHolder, ffi.Uint64,
              Port_Result)>>('file_truncate');
  late final _file_truncate =
      _file_truncatePtr.asFunction<void Function(int, int, int, int)>();

  /// Retrieve the size of the file in bytes.
  void file_len(
    int session,
    int handle,
    int port,
  ) {
    return _file_len(
      session,
      handle,
      port,
    );
  }

  late final _file_lenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_FileHolder, Port_Result_u64)>>('file_len');
  late final _file_len =
      _file_lenPtr.asFunction<void Function(int, int, int)>();

  /// Copy the file contents into the provided raw file descriptor.
  /// This function takes ownership of the file descriptor and closes it when it finishes. If the
  /// caller needs to access the descriptor afterwards (or while the function is running), he/she
  /// needs to `dup` it before passing it into this function.
  void file_copy_to_raw_fd(
    int session,
    int handle,
    int fd,
    int port,
  ) {
    return _file_copy_to_raw_fd(
      session,
      handle,
      fd,
      port,
    );
  }

  late final _file_copy_to_raw_fdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_FileHolder, ffi.Int,
              Port_Result)>>('file_copy_to_raw_fd');
  late final _file_copy_to_raw_fd =
      _file_copy_to_raw_fdPtr.asFunction<void Function(int, int, int, int)>();

  /// Creates a ouisync session. `post_c_object_fn` should be a pointer to the dart's
  /// `NativeApi.postCObject` function cast to `Pointer<Void>` (the casting is necessary to work
  /// around limitations of the binding generators).
  SessionCreateResult session_create(
    ffi.Pointer<ffi.Void> post_c_object_fn,
    ffi.Pointer<ffi.Char> configs_path,
  ) {
    return _session_create(
      post_c_object_fn,
      configs_path,
    );
  }

  late final _session_createPtr = _lookup<
      ffi.NativeFunction<
          SessionCreateResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>>('session_create');
  late final _session_create = _session_createPtr.asFunction<
      SessionCreateResult Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  /// Destroys the ouisync session.
  void session_destroy(
    int session,
  ) {
    return _session_destroy(
      session,
    );
  }

  late final _session_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SessionHandle)>>(
          'session_destroy');
  late final _session_destroy =
      _session_destroyPtr.asFunction<void Function(int)>();

  /// Create in-memory interface channel for when the client and the server are both in the same
  /// process.
  int session_channel_open(
    int session,
    int port,
  ) {
    return _session_channel_open(
      session,
      port,
    );
  }

  late final _session_channel_openPtr = _lookup<
      ffi.NativeFunction<
          Handle_ClientSender Function(
              SessionHandle, Port_Vec_u8)>>('session_channel_open');
  late final _session_channel_open =
      _session_channel_openPtr.asFunction<int Function(int, int)>();

  void session_channel_send(
    int session,
    int sender,
    ffi.Pointer<ffi.Uint8> payload_ptr,
    int payload_len,
  ) {
    return _session_channel_send(
      session,
      sender,
      payload_ptr,
      payload_len,
    );
  }

  late final _session_channel_sendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_ClientSender,
              ffi.Pointer<ffi.Uint8>, ffi.Uint64)>>('session_channel_send');
  late final _session_channel_send = _session_channel_sendPtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Uint8>, int)>();

  void session_channel_close(
    int session,
    int sender,
  ) {
    return _session_channel_close(
      session,
      sender,
    );
  }

  late final _session_channel_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_ClientSender)>>('session_channel_close');
  late final _session_channel_close =
      _session_channel_closePtr.asFunction<void Function(int, int)>();

  /// Shutdowns the network and closes the session. This is equivalent to doing it in two steps
  /// (`network_shutdown` then `session_close`), but in flutter when the engine is being detached
  /// from Android runtime then async wait for `network_shutdown` never completes (or does so
  /// randomly), and thus `session_close` is never invoked. My guess is that because the dart engine
  /// is being detached we can't do any async await on the dart side anymore, and thus need to do it
  /// here.
  void session_shutdown_network_and_close(
    int session,
  ) {
    return _session_shutdown_network_and_close(
      session,
    );
  }

  late final _session_shutdown_network_and_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SessionHandle)>>(
          'session_shutdown_network_and_close');
  late final _session_shutdown_network_and_close =
      _session_shutdown_network_and_closePtr.asFunction<void Function(int)>();

  /// Deallocate string that has been allocated on the rust side
  void free_string(
    ffi.Pointer<ffi.Char> ptr,
  ) {
    return _free_string(
      ptr,
    );
  }

  late final _free_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'free_string');
  late final _free_string =
      _free_stringPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Deallocate Bytes that has been allocated on the rust side
  void free_bytes(
    Bytes bytes,
  ) {
    return _free_bytes(
      bytes,
    );
  }

  late final _free_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Bytes)>>('free_bytes');
  late final _free_bytes = _free_bytesPtr.asFunction<void Function(Bytes)>();

  /// Returns the access mode of the given share token.
  int share_token_mode(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_mode(
      token,
    );
  }

  late final _share_token_modePtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Char>)>>(
          'share_token_mode');
  late final _share_token_mode =
      _share_token_modePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Returns the info-hash of the repository corresponding to the share token formatted as hex
  /// string.
  /// User is responsible for deallocating the returned string.
  ffi.Pointer<ffi.Char> share_token_info_hash(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_info_hash(
      token,
    );
  }

  late final _share_token_info_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('share_token_info_hash');
  late final _share_token_info_hash = _share_token_info_hashPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// IMPORTANT: the caller is responsible for deallocating the returned pointer unless it is `null`.
  ffi.Pointer<ffi.Char> share_token_suggested_name(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_suggested_name(
      token,
    );
  }

  late final _share_token_suggested_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('share_token_suggested_name');
  late final _share_token_suggested_name = _share_token_suggested_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Take the input string, decide whether it's a valid OuiSync token and normalize it (remove white
  /// space, unnecessary slashes,...).
  /// IMPORTANT: the caller is responsible for deallocating the returned buffer unless it is `null`.
  ffi.Pointer<ffi.Char> share_token_normalize(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_normalize(
      token,
    );
  }

  late final _share_token_normalizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('share_token_normalize');
  late final _share_token_normalize = _share_token_normalizePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// IMPORTANT: the caller is responsible for deallocating the returned buffer unless it is `null`.
  Bytes share_token_encode(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_encode(
      token,
    );
  }

  late final _share_token_encodePtr =
      _lookup<ffi.NativeFunction<Bytes Function(ffi.Pointer<ffi.Char>)>>(
          'share_token_encode');
  late final _share_token_encode = _share_token_encodePtr
      .asFunction<Bytes Function(ffi.Pointer<ffi.Char>)>();

  /// IMPORTANT: the caller is responsible for deallocating the returned pointer unless it is `null`.
  ffi.Pointer<ffi.Char> share_token_decode(
    ffi.Pointer<ffi.Uint8> bytes,
    int len,
  ) {
    return _share_token_decode(
      bytes,
      len,
    );
  }

  late final _share_token_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Uint64)>>('share_token_decode');
  late final _share_token_decode = _share_token_decodePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Uint8>, int)>();
}

abstract class ErrorCode {
  /// No error
  static const int ok = 0;

  /// Database error
  static const int db = 1;

  /// Insuficient permission to perform the intended operation
  static const int permissionDenied = 2;

  /// Malformed data
  static const int malformedData = 3;

  /// Entry already exists
  static const int entryExists = 4;

  /// Entry doesn't exist
  static const int entryNotFound = 5;

  /// Multiple matching entries found
  static const int ambiguousEntry = 6;

  /// The intended operation requires the directory to be empty but it isn't
  static const int directoryNotEmpty = 7;

  /// The indended operation is not supported
  static const int operationNotSupported = 8;

  /// Failed to read from or write into the device ID config file
  static const int deviceIdConfig = 10;

  /// Unspecified error
  static const int other = 65535;
}

class SessionCreateResult extends ffi.Struct {
  @SessionHandle()
  external int session;

  @ErrorCode1()
  external int error_code;

  external ffi.Pointer<ffi.Char> error_message;
}

typedef SessionHandle = UniqueHandle_Session;

/// FFI handle to a resource with unique ownership.
typedef UniqueHandle_Session = ffi.Uint64;
typedef ErrorCode1 = ffi.Uint16;

class Bytes extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> ptr;

  @ffi.Uint64()
  external int len;
}

typedef Handle_RepositoryHolder = ffi.Uint64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_Handle_FileHolder = Port;
typedef Port = ffi.Int64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result = Port;
typedef Handle_FileHolder = ffi.Uint64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_u64 = Port;
typedef Handle_ClientSender = ffi.Uint64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Vec_u8 = Port;

const int NETWORK_EVENT_PROTOCOL_VERSION_MISMATCH = 0;

const int NETWORK_EVENT_PEER_SET_CHANGE = 1;

const int ENTRY_TYPE_FILE = 1;

const int ENTRY_TYPE_DIRECTORY = 2;

const int ACCESS_MODE_BLIND = 0;

const int ACCESS_MODE_READ = 1;

const int ACCESS_MODE_WRITE = 2;
