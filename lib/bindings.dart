// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to the ouisync library
class Bindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Bindings(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Bindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void directory_create(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _directory_create(
      session,
      repo,
      path,
      port,
    );
  }

  late final _directory_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>, Port_Result)>>('directory_create');
  late final _directory_create = _directory_createPtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  void directory_open(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _directory_open(
      session,
      repo,
      path,
      port,
    );
  }

  late final _directory_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              Port_Result_Handle_Directory)>>('directory_open');
  late final _directory_open = _directory_openPtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// Removes the directory at the given path from the repository. The directory must be empty.
  void directory_remove(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _directory_remove(
      session,
      repo,
      path,
      port,
    );
  }

  late final _directory_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>, Port_Result)>>('directory_remove');
  late final _directory_remove = _directory_removePtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// Removes the directory at the given path including its content from the repository.
  void directory_remove_recursively(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _directory_remove_recursively(
      session,
      repo,
      path,
      port,
    );
  }

  late final _directory_remove_recursivelyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              Port_Result)>>('directory_remove_recursively');
  late final _directory_remove_recursively = _directory_remove_recursivelyPtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  void directory_close(
    int session,
    int handle,
  ) {
    return _directory_close(
      session,
      handle,
    );
  }

  late final _directory_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_Directory)>>('directory_close');
  late final _directory_close =
      _directory_closePtr.asFunction<void Function(int, int)>();

  int directory_num_entries(
    int session,
    int handle,
  ) {
    return _directory_num_entries(
      session,
      handle,
    );
  }

  late final _directory_num_entriesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(
              SessionHandle, Handle_Directory)>>('directory_num_entries');
  late final _directory_num_entries =
      _directory_num_entriesPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> directory_entry_name(
    int session,
    int handle,
    int index,
  ) {
    return _directory_entry_name(
      session,
      handle,
      index,
    );
  }

  late final _directory_entry_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(SessionHandle, Handle_Directory,
              ffi.Uint64)>>('directory_entry_name');
  late final _directory_entry_name = _directory_entry_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, int, int)>();

  int directory_entry_type(
    int session,
    int handle,
    int index,
  ) {
    return _directory_entry_type(
      session,
      handle,
      index,
    );
  }

  late final _directory_entry_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(SessionHandle, Handle_Directory,
              ffi.Uint64)>>('directory_entry_type');
  late final _directory_entry_type =
      _directory_entry_typePtr.asFunction<int Function(int, int, int)>();

  void file_open(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _file_open(
      session,
      repo,
      path,
      port,
    );
  }

  late final _file_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              Port_Result_Handle_FileHolder)>>('file_open');
  late final _file_open = _file_openPtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  void file_create(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _file_create(
      session,
      repo,
      path,
      port,
    );
  }

  late final _file_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              Port_Result_Handle_FileHolder)>>('file_create');
  late final _file_create = _file_createPtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// Remove (delete) the file at the given path from the repository.
  void file_remove(
    int session,
    int repo,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _file_remove(
      session,
      repo,
      path,
      port,
    );
  }

  late final _file_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>, Port_Result)>>('file_remove');
  late final _file_remove = _file_removePtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  void file_close(
    int session,
    int handle,
    int port,
  ) {
    return _file_close(
      session,
      handle,
      port,
    );
  }

  late final _file_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_FileHolder, Port_Result)>>('file_close');
  late final _file_close =
      _file_closePtr.asFunction<void Function(int, int, int)>();

  void file_flush(
    int session,
    int handle,
    int port,
  ) {
    return _file_flush(
      session,
      handle,
      port,
    );
  }

  late final _file_flushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_FileHolder, Port_Result)>>('file_flush');
  late final _file_flush =
      _file_flushPtr.asFunction<void Function(int, int, int)>();

  /// Read at most `len` bytes from the file into `buffer`. Yields the number of bytes actually read
  /// (zero on EOF).
  void file_read(
    int session,
    int handle,
    int offset,
    ffi.Pointer<ffi.Uint8> buffer,
    int len,
    int port,
  ) {
    return _file_read(
      session,
      handle,
      offset,
      buffer,
      len,
      port,
    );
  }

  late final _file_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_FileHolder,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              Port_Result_u64)>>('file_read');
  late final _file_read = _file_readPtr.asFunction<
      void Function(int, int, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Write `len` bytes from `buffer` into the file.
  void file_write(
    int session,
    int handle,
    int offset,
    ffi.Pointer<ffi.Uint8> buffer,
    int len,
    int port,
  ) {
    return _file_write(
      session,
      handle,
      offset,
      buffer,
      len,
      port,
    );
  }

  late final _file_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_FileHolder, ffi.Uint64,
              ffi.Pointer<ffi.Uint8>, ffi.Uint64, Port_Result)>>('file_write');
  late final _file_write = _file_writePtr.asFunction<
      void Function(int, int, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Truncate the file to `len` bytes.
  void file_truncate(
    int session,
    int handle,
    int len,
    int port,
  ) {
    return _file_truncate(
      session,
      handle,
      len,
      port,
    );
  }

  late final _file_truncatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_FileHolder, ffi.Uint64,
              Port_Result)>>('file_truncate');
  late final _file_truncate =
      _file_truncatePtr.asFunction<void Function(int, int, int, int)>();

  /// Retrieve the size of the file in bytes.
  void file_len(
    int session,
    int handle,
    int port,
  ) {
    return _file_len(
      session,
      handle,
      port,
    );
  }

  late final _file_lenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_FileHolder, Port_Result_u64)>>('file_len');
  late final _file_len =
      _file_lenPtr.asFunction<void Function(int, int, int)>();

  /// Copy the file contents into the provided raw file descriptor.
  /// This function takes ownership of the file descriptor and closes it when it finishes. If the
  /// caller needs to access the descriptor afterwards (or while the function is running), he/she
  /// needs to `dup` it before passing it into this function.
  void file_copy_to_raw_fd(
    int session,
    int handle,
    int fd,
    int port,
  ) {
    return _file_copy_to_raw_fd(
      session,
      handle,
      fd,
      port,
    );
  }

  late final _file_copy_to_raw_fdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_FileHolder, ffi.Int,
              Port_Result)>>('file_copy_to_raw_fd');
  late final _file_copy_to_raw_fd =
      _file_copy_to_raw_fdPtr.asFunction<void Function(int, int, int, int)>();

  /// Binds the network to the specified addresses.
  /// Rebinds if already bound. If any of the addresses is null, that particular protocol/family
  /// combination is not bound. If all are null the network is disabled.
  /// Yields `Ok` if the binding was successful, `Err` if any of the given addresses failed to
  /// parse or are were of incorrect type (e.g. IPv4 instead of IpV6).
  void network_bind(
    int session,
    ffi.Pointer<ffi.Char> quic_v4,
    ffi.Pointer<ffi.Char> quic_v6,
    ffi.Pointer<ffi.Char> tcp_v4,
    ffi.Pointer<ffi.Char> tcp_v6,
    int port,
  ) {
    return _network_bind(
      session,
      quic_v4,
      quic_v6,
      tcp_v4,
      tcp_v6,
      port,
    );
  }

  late final _network_bindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              Port_Result)>>('network_bind');
  late final _network_bind = _network_bindPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Subscribe to network event notifications.
  int network_subscribe(
    int session,
    int port,
  ) {
    return _network_subscribe(
      session,
      port,
    );
  }

  late final _network_subscribePtr = _lookup<
      ffi.NativeFunction<
          Handle_JoinHandle Function(
              SessionHandle, Port_u8)>>('network_subscribe');
  late final _network_subscribe =
      _network_subscribePtr.asFunction<int Function(int, int)>();

  /// Gracefully disconnect from peers.
  void network_shutdown(
    int session,
    int port,
  ) {
    return _network_shutdown(
      session,
      port,
    );
  }

  late final _network_shutdownPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(SessionHandle, Port_Result)>>(
      'network_shutdown');
  late final _network_shutdown =
      _network_shutdownPtr.asFunction<void Function(int, int)>();

  /// Return the local TCP network endpoint as a string. The format is "<IPv4>:<PORT>". The
  /// returned pointer may be null if we did not bind to a TCP IPv4 address.
  ///
  /// Example: "192.168.1.1:65522"
  ///
  /// IMPORTANT: the caller is responsible for deallocating the returned pointer.
  ffi.Pointer<ffi.Char> network_tcp_listener_local_addr_v4(
    int session,
  ) {
    return _network_tcp_listener_local_addr_v4(
      session,
    );
  }

  late final _network_tcp_listener_local_addr_v4Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SessionHandle)>>(
      'network_tcp_listener_local_addr_v4');
  late final _network_tcp_listener_local_addr_v4 =
      _network_tcp_listener_local_addr_v4Ptr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Return the local TCP network endpoint as a string. The format is "<[IPv6]>:<PORT>". The
  /// returned pointer pointer may be null if we did bind to a TCP IPv6 address.
  ///
  /// Example: "[2001:db8::1]:65522"
  ///
  /// IMPORTANT: the caller is responsible for deallocating the returned pointer.
  ffi.Pointer<ffi.Char> network_tcp_listener_local_addr_v6(
    int session,
  ) {
    return _network_tcp_listener_local_addr_v6(
      session,
    );
  }

  late final _network_tcp_listener_local_addr_v6Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SessionHandle)>>(
      'network_tcp_listener_local_addr_v6');
  late final _network_tcp_listener_local_addr_v6 =
      _network_tcp_listener_local_addr_v6Ptr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Return the local QUIC/UDP network endpoint as a string. The format is "<IPv4>:<PORT>". The
  /// returned pointer may be null if we did not bind to a QUIC/UDP IPv4 address.
  ///
  /// Example: "192.168.1.1:65522"
  ///
  /// IMPORTANT: the caller is responsible for deallocating the returned pointer.
  ffi.Pointer<ffi.Char> network_quic_listener_local_addr_v4(
    int session,
  ) {
    return _network_quic_listener_local_addr_v4(
      session,
    );
  }

  late final _network_quic_listener_local_addr_v4Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SessionHandle)>>(
      'network_quic_listener_local_addr_v4');
  late final _network_quic_listener_local_addr_v4 =
      _network_quic_listener_local_addr_v4Ptr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Return the local QUIC/UDP network endpoint as a string. The format is "<[IPv6]>:<PORT>". The
  /// returned pointer may be null if we did bind to a QUIC/UDP IPv6 address.
  ///
  /// Example: "[2001:db8::1]:65522"
  ///
  /// IMPORTANT: the caller is responsible for deallocating the returned pointer.
  ffi.Pointer<ffi.Char> network_quic_listener_local_addr_v6(
    int session,
  ) {
    return _network_quic_listener_local_addr_v6(
      session,
    );
  }

  late final _network_quic_listener_local_addr_v6Ptr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SessionHandle)>>(
      'network_quic_listener_local_addr_v6');
  late final _network_quic_listener_local_addr_v6 =
      _network_quic_listener_local_addr_v6Ptr
          .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Add a QUIC endpoint to which which OuiSync shall attempt to connect. Upon failure or success
  /// but then disconnection, the endpoint be retried until the below
  /// `network_remove_user_provided_quic_peer` function with the same endpoint is called.
  ///
  /// The endpoint provided to this function may be an IPv4 endpoint in the format
  /// "192.168.0.1:1234", or an IPv6 address in the format "[2001:db8:1]:1234".
  ///
  /// If the format is not parsed correctly, this function returns `false`, in all other cases it
  /// returns `true`. The latter includes the case when the peer has already been added.
  bool network_add_user_provided_quic_peer(
    int session,
    ffi.Pointer<ffi.Char> addr,
  ) {
    return _network_add_user_provided_quic_peer(
      session,
      addr,
    );
  }

  late final _network_add_user_provided_quic_peerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(SessionHandle,
              ffi.Pointer<ffi.Char>)>>('network_add_user_provided_quic_peer');
  late final _network_add_user_provided_quic_peer =
      _network_add_user_provided_quic_peerPtr
          .asFunction<bool Function(int, ffi.Pointer<ffi.Char>)>();

  /// Remove a QUIC endpoint from the list of user provided QUIC peers (added by the above
  /// `network_add_user_provided_quic_peer` function). Note that users added by other discovery
  /// mechanisms are not affected by this function. Also, removing a peer will not cause
  /// disconnection if the connection has already been established. But if the peers disconnected due
  /// to other reasons, the connection to this `addr` shall not be reattempted after the call to this
  /// function.
  ///
  /// The endpoint provided to this function may be an IPv4 endpoint in the format
  /// "192.168.0.1:1234", or an IPv6 address in the format "[2001:db8:1]:1234".
  ///
  /// If the format is not parsed correctly, this function returns `false`, in all other cases it
  /// returns `true`. The latter includes the case when the peer has not been previously added.
  bool network_remove_user_provided_quic_peer(
    int session,
    ffi.Pointer<ffi.Char> addr,
  ) {
    return _network_remove_user_provided_quic_peer(
      session,
      addr,
    );
  }

  late final _network_remove_user_provided_quic_peerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(SessionHandle, ffi.Pointer<ffi.Char>)>>(
      'network_remove_user_provided_quic_peer');
  late final _network_remove_user_provided_quic_peer =
      _network_remove_user_provided_quic_peerPtr
          .asFunction<bool Function(int, ffi.Pointer<ffi.Char>)>();

  /// Return the list of peers with which we're connected, serialized with msgpack.
  Bytes network_connected_peers(
    int session,
  ) {
    return _network_connected_peers(
      session,
    );
  }

  late final _network_connected_peersPtr =
      _lookup<ffi.NativeFunction<Bytes Function(SessionHandle)>>(
          'network_connected_peers');
  late final _network_connected_peers =
      _network_connected_peersPtr.asFunction<Bytes Function(int)>();

  /// Returns our runtime id formatted as a hex string.
  /// The caller is responsible for deallocating it.
  ffi.Pointer<ffi.Char> network_this_runtime_id(
    int session,
  ) {
    return _network_this_runtime_id(
      session,
    );
  }

  late final _network_this_runtime_idPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(SessionHandle)>>(
      'network_this_runtime_id');
  late final _network_this_runtime_id = _network_this_runtime_idPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Return our currently used protocol version number.
  int network_current_protocol_version(
    int session,
  ) {
    return _network_current_protocol_version(
      session,
    );
  }

  late final _network_current_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(SessionHandle)>>(
          'network_current_protocol_version');
  late final _network_current_protocol_version =
      _network_current_protocol_versionPtr.asFunction<int Function(int)>();

  /// Return the highest seen protocol version number. The value returned is always higher
  /// or equal to the value returned from network_current_protocol_version() fn.
  int network_highest_seen_protocol_version(
    int session,
  ) {
    return _network_highest_seen_protocol_version(
      session,
    );
  }

  late final _network_highest_seen_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(SessionHandle)>>(
          'network_highest_seen_protocol_version');
  late final _network_highest_seen_protocol_version =
      _network_highest_seen_protocol_versionPtr.asFunction<int Function(int)>();

  /// Enables port forwarding (UPnP)
  void network_enable_port_forwarding(
    int session,
  ) {
    return _network_enable_port_forwarding(
      session,
    );
  }

  late final _network_enable_port_forwardingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SessionHandle)>>(
          'network_enable_port_forwarding');
  late final _network_enable_port_forwarding =
      _network_enable_port_forwardingPtr.asFunction<void Function(int)>();

  /// Disables port forwarding (UPnP)
  void network_disable_port_forwarding(
    int session,
  ) {
    return _network_disable_port_forwarding(
      session,
    );
  }

  late final _network_disable_port_forwardingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SessionHandle)>>(
          'network_disable_port_forwarding');
  late final _network_disable_port_forwarding =
      _network_disable_port_forwardingPtr.asFunction<void Function(int)>();

  /// Checks whether port forwarding (UPnP) is enabled
  bool network_is_port_forwarding_enabled(
    int session,
  ) {
    return _network_is_port_forwarding_enabled(
      session,
    );
  }

  late final _network_is_port_forwarding_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(SessionHandle)>>(
          'network_is_port_forwarding_enabled');
  late final _network_is_port_forwarding_enabled =
      _network_is_port_forwarding_enabledPtr.asFunction<bool Function(int)>();

  /// Enables local discovery
  void network_enable_local_discovery(
    int session,
  ) {
    return _network_enable_local_discovery(
      session,
    );
  }

  late final _network_enable_local_discoveryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SessionHandle)>>(
          'network_enable_local_discovery');
  late final _network_enable_local_discovery =
      _network_enable_local_discoveryPtr.asFunction<void Function(int)>();

  /// Disables local discovery
  void network_disable_local_discovery(
    int session,
  ) {
    return _network_disable_local_discovery(
      session,
    );
  }

  late final _network_disable_local_discoveryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SessionHandle)>>(
          'network_disable_local_discovery');
  late final _network_disable_local_discovery =
      _network_disable_local_discoveryPtr.asFunction<void Function(int)>();

  /// Checks whether local discovery is enabled
  bool network_is_local_discovery_enabled(
    int session,
  ) {
    return _network_is_local_discovery_enabled(
      session,
    );
  }

  late final _network_is_local_discovery_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(SessionHandle)>>(
          'network_is_local_discovery_enabled');
  late final _network_is_local_discovery_enabled =
      _network_is_local_discovery_enabledPtr.asFunction<bool Function(int)>();

  /// Creates a new repository and set access to it based on the following table:
  ///
  /// local_read_password  |  local_write_password  |  token access  |  result
  /// ---------------------+------------------------+----------------+------------------------------
  /// null or any          |  null or any           |  blind         |  blind replica
  /// null                 |  null or any           |  read          |  read without password
  /// read_pwd             |  null or any           |  read          |  read with read_pwd as password
  /// null                 |  null                  |  write         |  read and write without password
  /// any                  |  null                  |  write         |  read (only!) with password
  /// null                 |  any                   |  write         |  read without password, require password for writing
  /// any                  |  any                   |  write         |  read with password, write with (same or different) password
  void repository_create(
    int session,
    ffi.Pointer<ffi.Char> store,
    ffi.Pointer<ffi.Char> local_read_password,
    ffi.Pointer<ffi.Char> local_write_password,
    ffi.Pointer<ffi.Char> share_token,
    int port,
  ) {
    return _repository_create(
      session,
      store,
      local_read_password,
      local_write_password,
      share_token,
      port,
    );
  }

  late final _repository_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              Port_Result_Handle_RepositoryHolder)>>('repository_create');
  late final _repository_create = _repository_createPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Opens an existing repository.
  void repository_open(
    int session,
    ffi.Pointer<ffi.Char> store,
    ffi.Pointer<ffi.Char> local_password,
    int port,
  ) {
    return _repository_open(
      session,
      store,
      local_password,
      port,
    );
  }

  late final _repository_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              Port_Result_Handle_RepositoryHolder)>>('repository_open');
  late final _repository_open = _repository_openPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// If `share_token` is null, the function will try with the currently active access secrets in the
  /// repository. Note that passing `share_token` explicitly (as opposed to implicitly using the
  /// currently active secrets) may be used to increase access permissions.
  ///
  /// Attempting to change the secret without enough permissions will fail with PermissionDenied
  /// error.
  ///
  /// If `local_read_password` is null, the repository will become readable without a password.
  /// To remove the read (and write) permission use the `repository_remove_read_access`
  /// function.
  void repository_set_read_access(
    int session,
    int handle,
    ffi.Pointer<ffi.Char> local_read_password,
    ffi.Pointer<ffi.Char> share_token,
    int port,
  ) {
    return _repository_set_read_access(
      session,
      handle,
      local_read_password,
      share_token,
      port,
    );
  }

  late final _repository_set_read_accessPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              Port_Result)>>('repository_set_read_access');
  late final _repository_set_read_access =
      _repository_set_read_accessPtr.asFunction<
          void Function(
              int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// If `share_token` is null, the function will try with the currently active access secrets in the
  /// repository. Note that passing `share_token` explicitly (as opposed to implicitly using the
  /// currently active secrets) may be used to increase access permissions.
  ///
  /// Attempting to change the secret without enough permissions will fail with PermissionDenied
  /// error.
  ///
  /// If `local_new_rw_password` is null, the repository will become read and writable without a
  /// password.  To remove the read and write access use the
  /// `repository_remove_read_and_write_access` function.
  ///
  /// The `local_old_rw_password` is optional (may be a null pointer), if it is set the previously
  /// used "writer ID" shall be used, otherwise a new one shall be generated. Note that it is
  /// preferred to keep the writer ID as it was, this reduces the number of writers in Version
  /// Vectors for every entry in the repository (files and directories) and thus reduces traffic and
  /// CPU usage when calculating causal relationships.
  void repository_set_read_and_write_access(
    int session,
    int handle,
    ffi.Pointer<ffi.Char> local_old_rw_password,
    ffi.Pointer<ffi.Char> local_new_rw_password,
    ffi.Pointer<ffi.Char> share_token,
    int port,
  ) {
    return _repository_set_read_and_write_access(
      session,
      handle,
      local_old_rw_password,
      local_new_rw_password,
      share_token,
      port,
    );
  }

  late final _repository_set_read_and_write_accessPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              Port_Result)>>('repository_set_read_and_write_access');
  late final _repository_set_read_and_write_access =
      _repository_set_read_and_write_accessPtr.asFunction<
          void Function(int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Note that after removing read key the user may still read the repository if they previously had
  /// write key set up.
  void repository_remove_read_key(
    int session,
    int handle,
    int port,
  ) {
    return _repository_remove_read_key(
      session,
      handle,
      port,
    );
  }

  late final _repository_remove_read_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              Port_Result)>>('repository_remove_read_key');
  late final _repository_remove_read_key =
      _repository_remove_read_keyPtr.asFunction<void Function(int, int, int)>();

  /// Note that removing the write key will leave read key intact.
  void repository_remove_write_key(
    int session,
    int handle,
    int port,
  ) {
    return _repository_remove_write_key(
      session,
      handle,
      port,
    );
  }

  late final _repository_remove_write_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              Port_Result)>>('repository_remove_write_key');
  late final _repository_remove_write_key = _repository_remove_write_keyPtr
      .asFunction<void Function(int, int, int)>();

  /// Closes a repository.
  void repository_close(
    int session,
    int handle,
    int port,
  ) {
    return _repository_close(
      session,
      handle,
      port,
    );
  }

  late final _repository_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              Port_Result)>>('repository_close');
  late final _repository_close =
      _repository_closePtr.asFunction<void Function(int, int, int)>();

  /// Returns true if the repository requires a local password to be opened for reading.
  void repository_requires_local_password_for_reading(
    int session,
    int handle,
    int port,
  ) {
    return _repository_requires_local_password_for_reading(
      session,
      handle,
      port,
    );
  }

  late final _repository_requires_local_password_for_readingPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  SessionHandle, Handle_RepositoryHolder, Port_Result_bool)>>(
      'repository_requires_local_password_for_reading');
  late final _repository_requires_local_password_for_reading =
      _repository_requires_local_password_for_readingPtr
          .asFunction<void Function(int, int, int)>();

  /// Returns true if the repository requires a local password to be opened for writing.
  void repository_requires_local_password_for_writing(
    int session,
    int handle,
    int port,
  ) {
    return _repository_requires_local_password_for_writing(
      session,
      handle,
      port,
    );
  }

  late final _repository_requires_local_password_for_writingPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  SessionHandle, Handle_RepositoryHolder, Port_Result_bool)>>(
      'repository_requires_local_password_for_writing');
  late final _repository_requires_local_password_for_writing =
      _repository_requires_local_password_for_writingPtr
          .asFunction<void Function(int, int, int)>();

  /// Return the info-hash of the repository formatted as hex string. This can be used as a globally
  /// unique, non-secret identifier of the repository.
  /// User is responsible for deallocating the returned string.
  ffi.Pointer<ffi.Char> repository_info_hash(
    int session,
    int handle,
  ) {
    return _repository_info_hash(
      session,
      handle,
    );
  }

  late final _repository_info_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              SessionHandle, Handle_RepositoryHolder)>>('repository_info_hash');
  late final _repository_info_hash = _repository_info_hashPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  /// Returns an ID that is randomly generated once per repository. Can be used to store local user
  /// data per repository (e.g. passwords behind biometric storage).
  void repository_database_id(
    int session,
    int handle,
    int port,
  ) {
    return _repository_database_id(
      session,
      handle,
      port,
    );
  }

  late final _repository_database_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              Port_Result_Vec_u8)>>('repository_database_id');
  late final _repository_database_id =
      _repository_database_idPtr.asFunction<void Function(int, int, int)>();

  /// Returns the type of repository entry (file, directory, ...).
  /// If the entry doesn't exists, returns `ENTRY_TYPE_INVALID`, not an error.
  void repository_entry_type(
    int session,
    int handle,
    ffi.Pointer<ffi.Char> path,
    int port,
  ) {
    return _repository_entry_type(
      session,
      handle,
      path,
      port,
    );
  }

  late final _repository_entry_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>, Port_Result_u8)>>('repository_entry_type');
  late final _repository_entry_type = _repository_entry_typePtr
      .asFunction<void Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// Move/rename entry from src to dst.
  void repository_move_entry(
    int session,
    int handle,
    ffi.Pointer<ffi.Char> src,
    ffi.Pointer<ffi.Char> dst,
    int port,
  ) {
    return _repository_move_entry(
      session,
      handle,
      src,
      dst,
      port,
    );
  }

  late final _repository_move_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              Port_Result)>>('repository_move_entry');
  late final _repository_move_entry = _repository_move_entryPtr.asFunction<
      void Function(
          int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Subscribe to change notifications from the repository.
  int repository_subscribe(
    int session,
    int handle,
    int port,
  ) {
    return _repository_subscribe(
      session,
      handle,
      port,
    );
  }

  late final _repository_subscribePtr = _lookup<
      ffi.NativeFunction<
          Handle_JoinHandle Function(SessionHandle, Handle_RepositoryHolder,
              Port)>>('repository_subscribe');
  late final _repository_subscribe =
      _repository_subscribePtr.asFunction<int Function(int, int, int)>();

  bool repository_is_dht_enabled(
    int session,
    int handle,
  ) {
    return _repository_is_dht_enabled(
      session,
      handle,
    );
  }

  late final _repository_is_dht_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(SessionHandle,
              Handle_RepositoryHolder)>>('repository_is_dht_enabled');
  late final _repository_is_dht_enabled =
      _repository_is_dht_enabledPtr.asFunction<bool Function(int, int)>();

  void repository_enable_dht(
    int session,
    int handle,
  ) {
    return _repository_enable_dht(
      session,
      handle,
    );
  }

  late final _repository_enable_dhtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle,
              Handle_RepositoryHolder)>>('repository_enable_dht');
  late final _repository_enable_dht =
      _repository_enable_dhtPtr.asFunction<void Function(int, int)>();

  void repository_disable_dht(
    int session,
    int handle,
  ) {
    return _repository_disable_dht(
      session,
      handle,
    );
  }

  late final _repository_disable_dhtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle,
              Handle_RepositoryHolder)>>('repository_disable_dht');
  late final _repository_disable_dht =
      _repository_disable_dhtPtr.asFunction<void Function(int, int)>();

  bool repository_is_pex_enabled(
    int session,
    int handle,
  ) {
    return _repository_is_pex_enabled(
      session,
      handle,
    );
  }

  late final _repository_is_pex_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(SessionHandle,
              Handle_RepositoryHolder)>>('repository_is_pex_enabled');
  late final _repository_is_pex_enabled =
      _repository_is_pex_enabledPtr.asFunction<bool Function(int, int)>();

  void repository_enable_pex(
    int session,
    int handle,
  ) {
    return _repository_enable_pex(
      session,
      handle,
    );
  }

  late final _repository_enable_pexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle,
              Handle_RepositoryHolder)>>('repository_enable_pex');
  late final _repository_enable_pex =
      _repository_enable_pexPtr.asFunction<void Function(int, int)>();

  void repository_disable_pex(
    int session,
    int handle,
  ) {
    return _repository_disable_pex(
      session,
      handle,
    );
  }

  late final _repository_disable_pexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle,
              Handle_RepositoryHolder)>>('repository_disable_pex');
  late final _repository_disable_pex =
      _repository_disable_pexPtr.asFunction<void Function(int, int)>();

  /// The `password` parameter is optional, if `null` the current access level of the opened
  /// repository is used. If provided, the highest access level that the password can unlock is used.
  void repository_create_share_token(
    int session,
    int handle,
    ffi.Pointer<ffi.Char> password,
    int access_mode,
    ffi.Pointer<ffi.Char> name,
    int port,
  ) {
    return _repository_create_share_token(
      session,
      handle,
      password,
      access_mode,
      name,
      port,
    );
  }

  late final _repository_create_share_tokenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle,
              Handle_RepositoryHolder,
              ffi.Pointer<ffi.Char>,
              ffi.Uint8,
              ffi.Pointer<ffi.Char>,
              Port_Result_String)>>('repository_create_share_token');
  late final _repository_create_share_token =
      _repository_create_share_tokenPtr.asFunction<
          void Function(int, int, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<ffi.Char>, int)>();

  int repository_access_mode(
    int session,
    int handle,
  ) {
    return _repository_access_mode(
      session,
      handle,
    );
  }

  late final _repository_access_modePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(SessionHandle,
              Handle_RepositoryHolder)>>('repository_access_mode');
  late final _repository_access_mode =
      _repository_access_modePtr.asFunction<int Function(int, int)>();

  /// Returns the syncing progress as a float in the 0.0 - 1.0 range.
  void repository_sync_progress(
    int session,
    int handle,
    int port,
  ) {
    return _repository_sync_progress(
      session,
      handle,
      port,
    );
  }

  late final _repository_sync_progressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle, Handle_RepositoryHolder,
              Port_Result_Vec_u8)>>('repository_sync_progress');
  late final _repository_sync_progress =
      _repository_sync_progressPtr.asFunction<void Function(int, int, int)>();

  /// Returns the access mode of the given share token.
  int share_token_mode(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_mode(
      token,
    );
  }

  late final _share_token_modePtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Char>)>>(
          'share_token_mode');
  late final _share_token_mode =
      _share_token_modePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Returns the info-hash of the repository corresponding to the share token formatted as hex
  /// string.
  /// User is responsible for deallocating the returned string.
  ffi.Pointer<ffi.Char> share_token_info_hash(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_info_hash(
      token,
    );
  }

  late final _share_token_info_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('share_token_info_hash');
  late final _share_token_info_hash = _share_token_info_hashPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// IMPORTANT: the caller is responsible for deallocating the returned pointer unless it is `null`.
  ffi.Pointer<ffi.Char> share_token_suggested_name(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_suggested_name(
      token,
    );
  }

  late final _share_token_suggested_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('share_token_suggested_name');
  late final _share_token_suggested_name = _share_token_suggested_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Take the input string, decide whether it's a valid OuiSync token and normalize it (remove white
  /// space, unnecessary slashes,...).
  /// IMPORTANT: the caller is responsible for deallocating the returned buffer unless it is `null`.
  ffi.Pointer<ffi.Char> share_token_normalize(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_normalize(
      token,
    );
  }

  late final _share_token_normalizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('share_token_normalize');
  late final _share_token_normalize = _share_token_normalizePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// IMPORTANT: the caller is responsible for deallocating the returned buffer unless it is `null`.
  Bytes share_token_encode(
    ffi.Pointer<ffi.Char> token,
  ) {
    return _share_token_encode(
      token,
    );
  }

  late final _share_token_encodePtr =
      _lookup<ffi.NativeFunction<Bytes Function(ffi.Pointer<ffi.Char>)>>(
          'share_token_encode');
  late final _share_token_encode = _share_token_encodePtr
      .asFunction<Bytes Function(ffi.Pointer<ffi.Char>)>();

  /// IMPORTANT: the caller is responsible for deallocating the returned pointer unless it is `null`.
  ffi.Pointer<ffi.Char> share_token_decode(
    ffi.Pointer<ffi.Uint8> bytes,
    int len,
  ) {
    return _share_token_decode(
      bytes,
      len,
    );
  }

  late final _share_token_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Uint64)>>('share_token_decode');
  late final _share_token_decode = _share_token_decodePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Opens the ouisync session. `post_c_object_fn` should be a pointer to the dart's
  /// `NativeApi.postCObject` function cast to `Pointer<Void>` (the casting is necessary to work
  /// around limitations of the binding generators).
  SessionOpenResult session_open(
    ffi.Pointer<ffi.Void> post_c_object_fn,
    ffi.Pointer<ffi.Char> configs_path,
  ) {
    return _session_open(
      post_c_object_fn,
      configs_path,
    );
  }

  late final _session_openPtr = _lookup<
      ffi.NativeFunction<
          SessionOpenResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>>('session_open');
  late final _session_open = _session_openPtr.asFunction<
      SessionOpenResult Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  /// Retrieve a serialized state monitor corresponding to the `path`.
  Bytes session_get_state_monitor(
    int session,
    ffi.Pointer<ffi.Uint8> path,
    int path_len,
  ) {
    return _session_get_state_monitor(
      session,
      path,
      path_len,
    );
  }

  late final _session_get_state_monitorPtr = _lookup<
      ffi.NativeFunction<
          Bytes Function(SessionHandle, ffi.Pointer<ffi.Uint8>,
              ffi.Uint64)>>('session_get_state_monitor');
  late final _session_get_state_monitor = _session_get_state_monitorPtr
      .asFunction<Bytes Function(int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Subscribe to "on change" events happening inside a monitor corresponding to the `path`.
  int session_state_monitor_subscribe(
    int session,
    ffi.Pointer<ffi.Uint8> path,
    int path_len,
    int port,
  ) {
    return _session_state_monitor_subscribe(
      session,
      path,
      path_len,
      port,
    );
  }

  late final _session_state_monitor_subscribePtr = _lookup<
      ffi.NativeFunction<
          NullableHandle_JoinHandle Function(
              SessionHandle,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint64,
              Port)>>('session_state_monitor_subscribe');
  late final _session_state_monitor_subscribe =
      _session_state_monitor_subscribePtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Unsubscribe from the above "on change" StateMonitor events.
  void session_state_monitor_unsubscribe(
    int session,
    int handle,
  ) {
    return _session_state_monitor_unsubscribe(
      session,
      handle,
    );
  }

  late final _session_state_monitor_unsubscribePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SessionHandle,
              NullableHandle_JoinHandle)>>('session_state_monitor_unsubscribe');
  late final _session_state_monitor_unsubscribe =
      _session_state_monitor_unsubscribePtr
          .asFunction<void Function(int, int)>();

  /// Closes the ouisync session.
  void session_close(
    int session,
  ) {
    return _session_close(
      session,
    );
  }

  late final _session_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SessionHandle)>>(
          'session_close');
  late final _session_close =
      _session_closePtr.asFunction<void Function(int)>();

  /// Shutdowns the network and closes the session. This is equivalent to doing it in two steps
  /// (`network_shutdown` then `session_close`), but in flutter when the engine is being detached
  /// from Android runtime then async wait for `network_shutdown` never completes (or does so
  /// randomly), and thus `session_close` is never invoked. My guess is that because the dart engine
  /// is being detached we can't do any async await on the dart side anymore, and thus need to do it
  /// here.
  void session_shutdown_network_and_close(
    int session,
  ) {
    return _session_shutdown_network_and_close(
      session,
    );
  }

  late final _session_shutdown_network_and_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(SessionHandle)>>(
          'session_shutdown_network_and_close');
  late final _session_shutdown_network_and_close =
      _session_shutdown_network_and_closePtr.asFunction<void Function(int)>();

  /// Cancel a notification subscription.
  void subscription_cancel(
    int session,
    int handle,
  ) {
    return _subscription_cancel(
      session,
      handle,
    );
  }

  late final _subscription_cancelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              SessionHandle, Handle_JoinHandle)>>('subscription_cancel');
  late final _subscription_cancel =
      _subscription_cancelPtr.asFunction<void Function(int, int)>();

  /// Deallocate string that has been allocated on the rust side
  void free_string(
    ffi.Pointer<ffi.Char> ptr,
  ) {
    return _free_string(
      ptr,
    );
  }

  late final _free_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'free_string');
  late final _free_string =
      _free_stringPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  /// Deallocate Bytes that has been allocated on the rust side
  void free_bytes(
    Bytes bytes,
  ) {
    return _free_bytes(
      bytes,
    );
  }

  late final _free_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Bytes)>>('free_bytes');
  late final _free_bytes = _free_bytesPtr.asFunction<void Function(Bytes)>();
}

abstract class ErrorCode {
  /// No error
  static const int ok = 0;

  /// Database error
  static const int db = 1;

  /// Insuficient permission to perform the intended operation
  static const int permissionDenied = 2;

  /// Malformed data
  static const int malformedData = 3;

  /// Entry already exists
  static const int entryExists = 4;

  /// Entry doesn't exist
  static const int entryNotFound = 5;

  /// Multiple matching entries found
  static const int ambiguousEntry = 6;

  /// The intended operation requires the directory to be empty but it isn't
  static const int directoryNotEmpty = 7;

  /// The indended operation is not supported
  static const int operationNotSupported = 8;

  /// Failed to read from or write into the device ID config file
  static const int deviceIdConfig = 10;

  /// Unspecified error
  static const int other = 65536;
}

class Bytes extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> ptr;

  @ffi.Uint64()
  external int len;
}

class SessionOpenResult extends ffi.Struct {
  @SessionHandle()
  external int session;

  @ffi.Int32()
  external int error_code;

  external ffi.Pointer<ffi.Char> error_message;
}

typedef SessionHandle = UniqueHandle_Session;

/// FFI handle to a resource with unique ownership.
typedef UniqueHandle_Session = ffi.Uint64;
typedef Handle_RepositoryHolder = ffi.Uint64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result = Port;
typedef Port = ffi.Int64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_Handle_Directory = Port;
typedef Handle_Directory = ffi.Uint64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_Handle_FileHolder = Port;
typedef Handle_FileHolder = ffi.Uint64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_u64 = Port;
typedef Handle_JoinHandle = ffi.Uint64;

/// Type-safe wrapper over native dart SendPort.
typedef Port_u8 = Port;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_Handle_RepositoryHolder = Port;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_bool = Port;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_Vec_u8 = Port;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_u8 = Port;

/// Type-safe wrapper over native dart SendPort.
typedef Port_Result_String = Port;
typedef NullableHandle_JoinHandle = Handle_JoinHandle;

const int NETWORK_EVENT_PROTOCOL_VERSION_MISMATCH = 0;

const int NETWORK_EVENT_PEER_SET_CHANGE = 1;

const int ENTRY_TYPE_INVALID = 0;

const int ENTRY_TYPE_FILE = 1;

const int ENTRY_TYPE_DIRECTORY = 2;

const int ACCESS_MODE_BLIND = 0;

const int ACCESS_MODE_READ = 1;

const int ACCESS_MODE_WRITE = 2;
